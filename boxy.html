<html>
<head>
<script src="https://code.createjs.com/preloadjs-0.6.2.min.js"></script>
<script src="https://code.createjs.com/easeljs-0.8.2.min.js"></script>
<script>
var boxy = boxy || {};

boxy.IDLE_TIME = 40;

boxy.MobileEntity = class {
  constructor(x, y, size, speed, sprite, mapStage) {
    this._x = x;
    this._y = y;
    this._size = size;
    this._speed = speed;
    this._sprite = sprite;
    this._mapStage = mapStage;
    this._stopTimer = 0;
    this._idle = false;
  }

  set nextDirection(dir) {
    this._nextDirection = dir;
  }

  get nextDirection() {
    return this._nextDirection;
  }

  get currentDirection() {
    return this._currentDirection;
  }

  set currentDirection(dir) {
    this._currentDirection = dir;
  }

  get x() {
    return this._x;
  }

  set x(x) {
    this._x = x;
  }

  get y() {
    return this._y;
  }

  set y(y) {
    this._y = y;
  }

  get size() {
    return this._size;
  }

  get speed() {
    return this._speed;
  }

  set speed(speed) {
    this._speed = speed;
  }

  update() {
    var dirs = this._mapStage.allowedDirections(this);

    // Check that the current direction is still allowed
    if (this.currentDirection != null && dirs.indexOf(this.currentDirection) == -1) {
      this.currentDirection = null;
      this.movementChange = true;
      this._stopTimer = 0;
    }

    // Switch to the next direction if possible
    if (this.nextDirection != null) {
      if (dirs.indexOf(this.nextDirection) != -1) {
        this.currentDirection = this.nextDirection;
        this.nextDirection = null;
        this.movementChange = true;
        this._idle = false;
      }
    }

    // If not moving, wait a bit then start to idle
    if (this.currentDirection == null) {
      this._stopTimer++;
    }
    if (this._stopTimer == boxy.IDLE_TIME) {
      this._idle = true;
      this._animationChange = true;
    }

    this.updatePosition();
    this.updateDisplay();
  }

  updatePosition() {
    if (this.currentDirection == null) {
      return;
    }

    switch (this.currentDirection) {
      case 0:
        this.y -= this.speed;
        return;
      case 1:
        this.x += this.speed;
        return;
      case 2:
        this.y += this.speed;
        return;
      case 3:
        this.x -= this.speed;
        return;
    }
  }

  updateDisplay() {
    this._sprite.x = this.x;
    this._sprite.y = this.y;

    if (this._animationChange) {
      if (this._idle) {
        this._sprite.gotoAndPlay("idle");
      }
      this._animationChange = false;
    }

    if (this.movementChange) {
      var dirName, stopMove;
      switch (this.currentDirection) {
        case 0:
          dirName = "up";
          break;
        case 1:
          dirName = "right";
          break;
        case 2:
          dirName = "down";
          break;
        case 3:
          dirName = "left";
          break;
        case null:
          stopMove = true;
          break;
      }
      if (stopMove) {
        this._sprite.stop();
      } else {
        this._sprite.gotoAndPlay("move_" + dirName);
      }

      this.movementChange = false;
    }
  }
}

boxy.StageMap = class {
  constructor(w, h) {
    this.w = w;
    this.h = h;
  }

  allowedDirections(mobileEntity) {
    var x = mobileEntity.x;
    var y = mobileEntity.y;
    var size = mobileEntity.size;

    var dirs = [];
    if (x > 0) {
      dirs.push(3);
    }
    if (x < (this.w - mobileEntity.size)) {
      dirs.push(1);
    }
    if (y > 0) {
      dirs.push(0);
    }
    if (y < (this.h - mobileEntity.size)) {
      dirs.push(2);
    }
    return dirs;
  }
}

boxy.game = (function () {
  var KEYCODE_DOWN = 40;
  var KEYCODE_UP = 38;
  var KEYCODE_LEFT = 37;
  var KEYCODE_RIGHT = 39;
  var KEYCODE_W = 87;
  var KEYCODE_A = 65;
  var KEYCODE_D = 68;
  var KEYCODE_S = 83;

  var KEYCODE_SPACE = 32;

  var stage, w, h;
  var loader;

  var stageMap;
  var mobileEntities;
  var playerEntity;

  document.onkeydown = handleKeyDown;

  var game = {};

  game.init = function() {
    stage = new createjs.Stage("boxyCanvas");
    w = stage.canvas.width;
    h = stage.canvas.height;

    manifest = [
        {src : "boxy_spritesheet.png", id : "boxy_sprite"}
    ];
    loader = new createjs.LoadQueue(false);
    loader.addEventListener("complete", handleComplete);
    loader.loadManifest(manifest, true, "art/");

    
  }

  function handleComplete() {
    background = new createjs.Shape();
    background.graphics.beginFill("#1a3149").drawRect(0, 0, w, h);

    var circle = new createjs.Shape();
    circle.graphics.beginFill("DeepSkyBlue").drawCircle(0, 0, 10);
    circle.x = 30;
    circle.y = 30;

    var spriteSheet = new createjs.SpriteSheet({
        framerate: 6,
        "images": [loader.getResult("boxy_sprite")],
        "frames": {"regX": 0, "height": 70, "count": 17, "regY": 0, "width": 70},
        // define two animations, run (loops, 1.5x speed) and jump (returns to run):
        "animations": {
          "move_right": {
            frames: [0,1,2,3,2,1],
            speed: 2
          },
          "move_left": {
            frames: [4,5,6,7,6,5],
            speed: 2
          },
          "move_down": {
            frames: [8,9,10,11,10,9],
            speed: 2
          },
          "move_up": {
            frames: [12,13,14,15,14,13],
            speed: 2
          },
          "idle": {
            frames: [8,8,8,16],
            speed: 0.3
          }
        }
      });
    var boxySprite = new createjs.Sprite(spriteSheet, "move_down");

    stage.addChild(background, circle, boxySprite);

    // Initialize game objects
    stageMap = new boxy.StageMap(w, h);
    mobileEntities = [];
    playerEntity = new boxy.MobileEntity(100, 100, 70, 5, boxySprite, stageMap);

    mobileEntities.push(playerEntity);

    createjs.Ticker.timingMode = createjs.Ticker.RAF;
    createjs.Ticker.addEventListener("tick", tick);
  }

  function tick(event) {
    mobileEntities.forEach(function(entity) {
      entity.update();
    });

    stage.update(event);
  }

  function handleKeyDown(e) {
    //cross browser issues exist
    if (!e) {
      var e = window.event;
    }
    switch (e.keyCode) {
      case KEYCODE_SPACE:
        shootHeld = true;
        return false;
      case KEYCODE_A:
      case KEYCODE_LEFT:
        playerEntity.nextDirection = 3;
        return false;
      case KEYCODE_D:
      case KEYCODE_RIGHT:
        playerEntity.nextDirection = 1;
        return false;
      case KEYCODE_W:
      case KEYCODE_UP:
        playerEntity.nextDirection = 0;
        return false;
      case KEYCODE_S:
      case KEYCODE_DOWN:
        playerEntity.nextDirection = 2;
        return false;
    }
  }

  return game;
})();

function init() {
  boxy.game.init();
}
</script>


</head>


<body onload="init();">
  <canvas id="boxyCanvas" width="500" height="300"></canvas>




</body>

</html>