<html>
<head>
<script src="https://code.jquery.com/jquery-2.2.4.min.js"></script>
<script src="https://code.createjs.com/preloadjs-0.6.2.min.js"></script>
<script src="https://code.createjs.com/easeljs-0.8.2.min.js"></script>
<script>
var boxy = boxy || {};

boxy.defaults = {
  idle_time: 40,
  grid_size: 70,
  map_file: "test.json"
};

boxy.MapEntity = class {
  constructor(row, column, sprite) {
    this._rc = [row, column];
    this._snapToGrid();
    this._sprite = sprite;
  }

  get xy() {
    return this._x;
  }

  set xy(xy) {
    this._xy = xy;
  }

  get rc() {
    return this._rc;
  }

  _snapToGrid() {
    this._xy = boxy.game.stageMap.gridToCoordinate(this._rc);
  }
}

boxy.CollectibleEntity = class extends boxy.MapEntity {
  constructor(row, column, sprite) {
    super(row, column, sprite);
  }


}

boxy.MobileEntity = class extends boxy.MapEntity {
  constructor(row, column, speed, sprite) {
    super(row, column, sprite);
    this._speed = speed;
    this._stopTimer = 0;
    this._idle = false;
  }

  set nextDirection(dir) {
    if (dir == this._currentDirection) {
      this._nextDirection = null;
      return this;
    }
    this._nextDirection = dir;
    return this;
  }

  get nextDirection() {
    return this._nextDirection;
  }

  get currentDirection() {
    return this._currentDirection;
  }

  set currentDirection(dir) {
    this._currentDirection = dir;
  }

  get speed() {
    return this._speed;
  }

  set speed(speed) {
    this._speed = speed;
  }

  update() {
    this.updatePosition();
    this.updateDisplay();

    // If not moving, wait a bit then start to idle
    if (this.currentDirection == null) {
      this._stopTimer++;
    }
    if (this._stopTimer == boxy.game.settings.idle_time) {
      this._idle = true;
      this._animationChange = true;
    }
  }

  movementStopped() {
    this.currentDirection = null;
    this.movementChange = true;
    this._stopTimer = 0;
  }

  _directionChanged() {
    this.currentDirection = this.nextDirection;
    this.nextDirection = null;
    this.movementChange = true;
    this._idle = false;
  }

  updatePosition() {
    if (this.currentDirection == null) {
      if (this.nextDirection != null) {
        this._directionChanged();
      }
      return this;
    }
    var newX = this._xy[0], newY = this._xy[1];
    var newGrid;

    switch (this.currentDirection) {
      case 0:
        newY -= this.speed;
        newGrid = boxy.game.stageMap.coordinateToGrid([newX, newY]);
        break;
      case 1:
        newX += this.speed;
        newGrid = boxy.game.stageMap.coordinateToGrid([newX + boxy.game.settings.grid_size, newY]);
        break;
      case 2:
        newY += this.speed;
        newGrid = boxy.game.stageMap.coordinateToGrid([newX, newY + boxy.game.settings.grid_size]);
        break;
      case 3:
        newX -= this.speed;
        newGrid = boxy.game.stageMap.coordinateToGrid([newX, newY]);
        break;
    }

    // Grid location has changed
    if (newGrid[0] != this._rc[0] || newGrid[1] != this._rc[1]) {
      if (this.nextDirection != null) {
        // Direct change is queued, try to see if we can change now
        var dirs = boxy.game.stageMap.allowedDirections(this._rc);
        if (dirs.indexOf(this.nextDirection) != -1) {
          this._directionChanged();
          this._snapToGrid();
        }
      }

      // Check to see if the new grid location would be a barrier
      if (!this.movementChange && boxy.game.stageMap.isBlocked(newGrid)) {
        // hit a wall, no new directions, so stop and snap to position
        this.movementStopped();
        this._snapToGrid();
      }
    }

    // Movement continues, update position info
    if (!this.movementChange) {
      this._xy = [newX, newY];
      this._rc = newGrid;
    }
  }

  updateDisplay() {
    this._sprite.x = this._xy[0];
    this._sprite.y = this._xy[1];

    if (this._animationChange) {
      if (this._idle) {
        this._sprite.gotoAndPlay("idle");
      }
      this._animationChange = false;
    }

    if (this.movementChange) {
      var dirName, stopMove;
      switch (this.currentDirection) {
        case 0:
          dirName = "up";
          break;
        case 1:
          dirName = "right";
          break;
        case 2:
          dirName = "down";
          break;
        case 3:
          dirName = "left";
          break;
        case null:
          stopMove = true;
          break;
      }
      if (stopMove) {
        this._sprite.stop();
      } else {
        this._sprite.gotoAndPlay("move_" + dirName);
      }

      this.movementChange = false;
    }
    return this;
  }
}

boxy.CollectiblesManager = class {
  constructor(spawnMap, tiles) {
    this._spawnMap = spawnMap;
    this._tiles = tiles;
    this._entites = [];
  }

  spawnAll() {
    for (var i = 0; i < this._spawnMap.length; i++) {
      var spawnRow = this._spawnMap[i];

      for (var j = 0; j < spawnRow; j++) {
        var spawn = spawnRow[j];

        if (this._locationSpawnable(i, j)) {

        }
      }
    }
  }

  _locationSpawnable(row, column) {
    if (this._tiles[row][column] == 1) {
      return false;
    }
    var playerLoc = game.playerEntity.rc;
    return playerLoc[0] == row && playerLoc[1] == column;
  }

  spawnEntity(spawnType) {

  }
}

boxy.StageMap = class {
  constructor(data, spriteImages) {
    this._mapData = data;

    this._loadSpritesheet(spriteImages);
  }

  get hasChanged() {
    return this._hasChanged;
  }

  _loadSpritesheet(spriteImages) {
    this._spriteSheet = new createjs.SpriteSheet({
        framerate: 0,
        "images": [spriteImages],
        "frames": {"regX": 0, "height": boxy.game.settings.grid_size, "count": 16, "regY": 0, "width": boxy.game.settings.grid_size}
      });
  }

  selectMap(mapId) {
    this._selectedId = mapId;
    this._selectedData = this._mapData[mapId];
    this._numRows = this._selectedData.tiles.length;
    this._numColumns = this._selectedData.tiles[0].length;

    this._computeMap();
    return this;
  }

  _computeMap() {
    var computed = [];

    var tiles = this._mapData[this._selectedId].tiles;
    for (var i = 0; i < tiles.length; i++) {
      var computedRow = [];
      computed.push(computedRow);
      var row = tiles[i];
      for (var j = 0; j < row.length; j++) {
        if (row[j] == 0) {
          // Not a wall, nothing else to check
          computedRow.push(-1);
          continue;
        }
        
        var connectUp = (i > 0 && tiles[i-1][j] == 1);
        var connectRight = (j < row.length - 1 && row[j+1] == 1);
        var connectDown = (i < tiles.length - 1 && tiles[i+1][j] == 1);
        var connectLeft = (j > 0 && row[j-1] == 1);

        if (connectUp && connectRight && connectLeft && connectDown) {
          // Internal wall
          computedRow.push(10)
        } else if (!connectUp && connectRight && connectLeft && connectDown) {
          computedRow.push(8);
        } else if (connectUp && !connectRight && connectLeft && connectDown) {
          computedRow.push(9);
        } else if (connectUp && connectRight && !connectLeft && connectDown) {
          computedRow.push(7);
        } else if (connectUp && connectRight && connectLeft && !connectDown) {
          computedRow.push(6);
        } else if (!connectUp && !connectRight && connectLeft && connectDown) {
          computedRow.push(4);
        } else if (!connectUp && connectRight && !connectLeft && connectDown) {
          computedRow.push(3);
        } else if (!connectUp && connectRight && connectLeft && !connectDown) {
          computedRow.push(1);
        } else if (connectUp && !connectRight && !connectLeft && connectDown) {
          computedRow.push(0);
        } else if (connectUp && !connectRight && connectLeft && !connectDown) {
          computedRow.push(5);
        } else if (connectUp && connectRight && !connectLeft && !connectDown) {
          computedRow.push(2);
        } else if (!connectUp && !connectRight && !connectLeft && connectDown) {
          computedRow.push(12);
        } else if (!connectUp && !connectRight && connectLeft && !connectDown) {
          computedRow.push(13);
        } else if (!connectUp && connectRight && !connectLeft && !connectDown) {
          computedRow.push(15);
        } else if (connectUp && !connectRight && !connectLeft && !connectDown) {
          computedRow.push(14);
        } else {
          // Stand alone
          computedRow.push(11);
        }
      }
    }

    this._computedMap = computed;
  }

  renderMap() {
    var grid = this._computedMap;

    for (var i = 0; i < grid.length; i++) {
      var row = grid[i];
      var offsetY = i * boxy.game.settings.grid_size;

      for (var j = 0; j < row.length; j++) {
        var tileValue = row[j];

        if (tileValue < 0) {
          continue;
        }

        var sprite = new createjs.Sprite(this._spriteSheet, tileValue);
        sprite.stop();
        sprite.x = j * boxy.game.settings.grid_size;
        sprite.y = offsetY;
        boxy.game.stage.addChild(sprite);
      }
    }

    return this;
  }

  allowedDirections(rc) {
    var dirs = [];
    var tiles = this._selectedData.tiles;
    var column = rc[1], row = rc[0];

    if (row > 0 && tiles[row - 1][column] == 0) {
      dirs.push(0);
    }
    if (row < this._numRows - 1 && tiles[row + 1][column] == 0) {
      dirs.push(2);
    }

    if (column < this._numColumns - 1 && tiles[row][column + 1] == 0) {
      dirs.push(1);
    }
    if (column > 0 && tiles[row][column - 1] == 0) {
      dirs.push(3);
    }

    return dirs;
  }

  isBlocked(rc) {
    return this._selectedData.tiles[rc[0]][rc[1]] == 1;
  }

  gridToCoordinate(rc) {
    return [rc[1] * boxy.game.settings.grid_size, rc[0] * boxy.game.settings.grid_size];
  }

  coordinateToGrid(xy) {
    var row = Math.floor(xy[1] / boxy.game.settings.grid_size);
    var column = Math.floor(xy[0] / boxy.game.settings.grid_size);
    return [row, column];
  }
}

boxy.game = (function () {
  var KEYCODE_DOWN = 40;
  var KEYCODE_UP = 38;
  var KEYCODE_LEFT = 37;
  var KEYCODE_RIGHT = 39;
  var KEYCODE_W = 87;
  var KEYCODE_A = 65;
  var KEYCODE_D = 68;
  var KEYCODE_S = 83;

  var KEYCODE_SPACE = 32;

  var stage, w, h;
  var loader;

  var stageMap;
  var mobileEntities;
  var playerEntity;

  document.onkeydown = handleKeyDown;

  var game = {};
  game.settings = boxy.defaults;

  game.init = function() {
    this.stage = new createjs.Stage("boxyCanvas");
    this.w = this.stage.canvas.width;
    this.h = this.stage.canvas.height;

    manifest = [
        {src : "boxy_spritesheet.png", id : "boxy_sprite"},
        {src : "map_spritesheet.png", id : "map_sprite"}
    ];
    mapsManifest = [
        {src : "test.json", id : "test_map"},
        {src : "test.json", id : "map2"}
    ];
    loader = new createjs.LoadQueue(false);
    loader.addEventListener("complete", handleComplete);
    loader.loadManifest(manifest, true, "art/");
    loader.loadManifest(mapsManifest, true, "maps/");
  }

  function handleComplete(eventx) {
    background = new createjs.Shape();
    background.graphics.beginFill("#1a3149").drawRect(0, 0, game.w, game.h);

    var circle = new createjs.Shape();
    circle.graphics.beginFill("DeepSkyBlue").drawCircle(0, 0, 10);
    circle.x = 30;
    circle.y = 30;

    var spriteSheet = new createjs.SpriteSheet({
        framerate: 6,
        "images": [loader.getResult("boxy_sprite")],
        "frames": {"regX": 0, "height": game.settings.grid_size, "count": 17, "regY": 0, "width": game.settings.grid_size},
        // define two animations, run (loops, 1.5x speed) and jump (returns to run):
        "animations": {
          "move_right": {
            frames: [0,1,2,3,2,1],
            speed: 2
          },
          "move_left": {
            frames: [4,5,6,7,6,5],
            speed: 2
          },
          "move_down": {
            frames: [8,9,10,11,10,9],
            speed: 2
          },
          "move_up": {
            frames: [12,13,14,15,14,13],
            speed: 2
          },
          "idle": {
            frames: [8,8,8,16],
            speed: 0.3
          }
        }
      });

    var boxySprite = new createjs.Sprite(spriteSheet, "move_down");

    game.stage.addChild(background, circle, boxySprite);
    
    // Setup map manager
    mapData = {};
    loader.getItems(true).forEach(function(loaded){
      if (loaded.item.path == "maps/") {
        mapData[loaded.item.id] = loaded.result;
      }
    });
    game.stageMap = new boxy.StageMap(mapData, loader.getResult("map_sprite"));
    game.stageMap.selectMap("test_map").renderMap();

    // Initialize game objects
    game.mobileEntities = [];
    game.playerEntity = new boxy.MobileEntity(1, 1, 5, boxySprite);

    game.mobileEntities.push(game.playerEntity);

    createjs.Ticker.timingMode = createjs.Ticker.RAF;
    createjs.Ticker.addEventListener("tick", tick);
  }

  function tick(event) {
    game.mobileEntities.forEach(function(entity) {
      entity.update();
    });

    game.stage.update(event);
  }

  function handleKeyDown(e) {
    //cross browser issues exist
    if (!e) {
      var e = window.event;
    }
    switch (e.keyCode) {
      case KEYCODE_SPACE:
        shootHeld = true;
        return false;
      case KEYCODE_A:
      case KEYCODE_LEFT:
        game.playerEntity.nextDirection = 3;
        return false;
      case KEYCODE_D:
      case KEYCODE_RIGHT:
        game.playerEntity.nextDirection = 1;
        return false;
      case KEYCODE_W:
      case KEYCODE_UP:
        game.playerEntity.nextDirection = 0;
        return false;
      case KEYCODE_S:
      case KEYCODE_DOWN:
        game.playerEntity.nextDirection = 2;
        return false;
    }
  }

  return game;
})();

function init() {
  boxy.game.init();
}
</script>


</head>


<body onload="init();">
  <canvas id="boxyCanvas" width="1120" height="630"></canvas>




</body>

</html>